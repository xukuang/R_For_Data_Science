## 数据可视化

### 3.1 引言

> 相比其他方法， 简单的图形能够给数据分析人员更深入、更多的信息。—John Tukey

这一章将将教会你如何使用ggplot2可视化你的数据。R有多个画图系统，然而ggplot2是最优雅和最通用的一个。ggplot2的语法规则在图形描述和图形建立方面是非常有逻辑性的。有了ggplot2，你可以做的更加快速，用到更多的方面。

如果你想在开始之前了解更多ggplot2的基础知识，我建议你阅读“图形的分层语法”。

#### 3.1.1 前提

在一张主要关注ggplot2，它是tidyverse的核心包之一。为了能够使用这一章我们将用到的数据集，帮助页面和函数，通过这段代码加载tidyverse。

```
library(tidyverse)
#> Loading tidyverse: ggplot2
#> Loading tidyverse: tibble
#> Loading tidyverse: tidyr
#> Loading tidyverse: readr
#> Loading tidyverse: purrr
#> Loading tidyverse: dplyr
#> Conflicts with tidy packages ----------------------------------------------
#> filter(): dplyr, stats
#> lag():    dplyr, stats
```

这一行代码加载了核心的tidyverse。这些包你几乎在每个数据分析中都能用得到。它也告诉你tidyverse包中的一些函数与基础的R函数相冲突(或者与你已经加载的其它R包冲突)。

如果你使用这个代码，返回了一个错误信息“there is no package called tidyverse”，你需要首先安装它，然后再次加载。

```
install.packages("tidyverse")
library(tidyverse)
```

你仅需要安装了一个包一次，但是每次打开一个新的界面时，你需要重新加载它。

如果我们清楚一个函数(或者数据集)来自哪个R包，我们可以使用这种特别的形式 package::function 。例如，ggplot2::ggplot()函数清楚地告诉你我们正在使用ggplot()函数来自ggplot2包。

### 3.2 前几步

让我们用我们的第一个图来回答一个问题：大引擎汽车是否比小引擎的汽车更燃油？你可能已经有了一个答案，但是你试图是你答案更加的准确。引擎大小和油燃效率之间究竟存在着什么样的关系？正相关？负相关？线性的？非线性的？

#### 3.2.1 mpg 数据框

你可以使用ggplot2中的mpg数据框(data frame)回答你的问题。数据框是一个矩形的数据集，列是变量名，行是观察值。mgp包含美国环境保护局对39个汽车模型的观测值。

1. displ，汽车的引擎大小，单位是升
2. hwy，汽车在高速路上的燃油效率，单位是每加仑的英里数。当行驶相同的距离的时候，低燃油效率的车会比高燃油效率的车有更多的油耗。

更多关于mpg，可以使用?mpg打开帮助页面。

#### 3.2.2 创建ggplot

为了画出mpg，运行下面的代码把displ投影到x轴，把hwy投影到y轴上。

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

这个图显示出引擎大小和燃油效率之间存在着负相关。换句话说，大引擎的汽车需要更多的燃料。这是支持还是拒绝你关于燃油效率和引擎大小的假设呢？

在ggplot2中，你可以使用ggplot()函数画图。ggplot()创建了坐标系统，你可以把图层添加到上面去。ggplot()第一个参数是图形使用的数据集。因此，ggplot(data = mpg)创建的是一幅空图，但是这个不是很有趣的，因此这里我们并没有展示。

你完全可以向ggplot()上添加图层来完成你的图像。函数geom_point()用来向你的图像上添加点图层，它会产生一系列离散点。ggplot2有许多几何图形函数，你可以向你的图像上添加不同的图层。通过本章，你将会学到关于它们的一大堆知识。

ggplot2中的每个图形函数都有一个映射参数。它定义了你的数据变量如何映射到可视化的性质之上。映射参数总是伴随着aes()出现，aes()函数的参数x和y限定了那些变量投影到x和y轴上。ggplot2从参数data中找到映射变量。本例中是mpg。

#### 3.2.3 图形模板

让我们把这个代码转换成一个可重用的用ggplot2制作图表的模板。为了作图，我们可以把下面的尖括号中的代码用数据集，作图函数，或映射集合替换。

```
ggplot(data = <DATA>)
<GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

这一章的余下部分将告诉你如何完成和扩展模板来制作不同类型的图形。我们将从映射部分开始。

#### 3.2.4 练习

1. 运行 ggplot(data = mpg) 你会看到什么呢？
2. mtcars数据集中有多少行？多少列？
3. drv变量的意思是什么呢？为了弄清楚这个，使用?mpg阅读帮助
4. 制作hwy和cyl的三点图
5. 如果你制作class和drv的三点图会发生什么？为什么plot并不是非常有用的？

### 3. 3 图形属性映射

> 图形的最大的价值是迫使我们注意到我们不曾注意的内容。

在下面这幅图中，一组点(红颜色)似乎落在了直线趋势的外面。这些车比预期有更高的里程数。如何解释这些车呢？

我们假设这些车是混合动力型的。检验这个假设的一种方法是查看每个车的class值。mpg数据集的class变量把车分为compact，midsize，和SUV型的。如果这些落在外面的点是混合动力型的，它们应该是compact汽车，或者supcompact汽车(记住这个数据集是在hybrid卡车和SUVS没有流行之前收集的)。

你能够添加第三个变量，如class变量，把它映射为图形属性添到二维散点图中。图形属性是图形对象中的可视属性。图形属性包括大小，形状和点的颜色。你可以通过改变图形属性的值用不同的方式显示点。因为我们已经使用值(value)来描述数据，我们使用水平(level)来描述图形属性。这里我们改变点的大小、形状和颜色水平使点变为小的，三角形的，圆形的。

你可以把数据集中变量映射到图形的属性上来展现数据信息。例如，你可以把class变量映射到点的颜色上来展示每辆车的类型。

```
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

(如果你喜欢英式英语，向Haddly那样，你可以用colour替换color。)

为了把一个变量映射到图形属性上，可以在aes()中把图形属性名和变量名连接起来。ggplot2将自动把图形属性的一个独特水平与变量的独特值连接起来，这个过程被称为缩放(scaling)。ggplot2也将自动添加图例，图例将给出每个水平代表的值。

颜色表明许多异常点都是两座车(two-seater)。这些车似乎不是混合动力型的(hybrids)，实际上是跑车(sport cars)。跑车有像SUVs和皮卡车(pickup trucks)那样更大的引擎，但车型却像中型(midsize)和紧凑型(compact)车那样非常小，这提高了它们的燃油效率。事后可以看出，这些车不太可能是混合动力型的车，因为它们有更大的引擎。

在上面的例子中，我们把class映射到了颜色属性上，但我们也可以用同样的方法把class属性映射到大小属性上。在这个例子中，每个点的大小将反映class属性。这里我们有一个担心，因为把一个没有顺序的变量(class)映射到一个有顺序的变量(size)上并不是一个好主意。

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
#> Warning: Using size for a discrete variable is not advised.
```

或者，我们可以把class映射到透明度(alpha)属性上，这可以控制点的透明度，或者点的大小。

```
# Left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
  
 # Left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```

SUVs车出现了什么情况？ggplot2一次只能使用六种的类型。在默认的情况下，当你使用形状属性(shape)时，多余的组别并不能被画出来。

对于每种图形属性(aesthetic)，你可以使用aes()把图形属性的名称和一个变量显示的变量连接起来。aes()函数可以一并集合图层使用的每个图形属性，并把它们传递给图层的映射参数上。这里强调一下x和y：点的x和y坐标是图形自身的属性，你可以把变量映射到可视化性质上展示数据信息。

一旦你映射一个图形属性，ggplot2将会处理余下的部分。它将对图形属性使用一个合理的缩放，并创建一个图例，这个图例来说明值与水平间的映射关系。对于x和y属性，ggplot2并不会创建一个图例，但是它会创建一个包含刻度和标签的坐标轴。坐标轴充当了图例，解释了位置和x之间的映射关系。

你也可以手动设置几何图形的图形属性。例如，我们能够把所有点的颜色设置为蓝色。

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

这里，颜色并不反映变量信息，而仅仅是改变了颜色的外观。为了手动设置图形属性，可以在几何函数中设置图形属性参数。你需要为图形属性设置一个有意义的值。

* 颜色的名称是字符串
* 点的大小单位是mm
* 点的形状是一个数字

#### 3.3.1 练习

1. 下面的代码发生了什么？为什么点的颜色不是蓝色的？

   ```
   ggplot(data = mpg) + 
     geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
   ```

2. mpg中的哪一个变量是分类型变量？哪一个变量是连续型的变量？(提示：这里输入?mpg查看dataset数据的说明文档)。当你运行mpg你如何查看这些信息？

3. 映射连续变量到color，size和shape。这些图形属性对于分类变量和连续型变量表现方式有何不同呢？

4. 如果你映射同一个变量到多个图形属性上会发生什么？

5. stroke属性是什么？它们处理何种的类型？(提示：使用 ?geom_point)

6. 如果你映射一些值而非一个变量到图形属性上，会发生什么？

### 3.4 常见问题

当你运行R代码，你可能会遇到一些问题。不用担心，这会发生在任何人身上。我已经写了多年的R代码，每天我仍然会遇到一些R代码不能工作的情况。

开始的时候，仔细比较你使用代码和书中的代码。R是非常挑剔的，一个错误的字符都会发生很大的不同。确保每一个匹配都是正确的。有时候，你运行了R代码，却没有发生任何事情。检查控制台的左侧，如果有一个+，它意味着R并每不认为你输入了完整的语法，在等着你完成输入。在这个情况下，这是非常容易的通过ESCAPE键跳出当前的命令来从新开始。

当你创建ggplot2图形时一个常见问题把+放在一个错误的地方：它应该放到命令的后面，而非前面。换句话说，确保你没有意外的写出这样的代码：

```
ggplot(data = mpg) 
+ geom_point(mapping = aes(x = displ, y = hwy))
```

如果你依然处在麻烦之中，试着使用帮助。你在控制台输入?function_name或者在RStudio中选择函数的名称按F1获得任何R函数帮助。如果帮助似乎并没有帮助，不用担心。直接浏览底部的例子，查找你不能明白的代码。

如果代码没有帮助，仔细阅读错误提示信息。有的时候答案就隐藏在那里面。但是当你是个R新手的话，答案可能隐藏在错提示信息当中，但是你可能并不能理解它。Google是一个非常棒的工具：试着搜索错误信息，因为别人也可能遇到同样的问题，你可能在网上获得帮助。

### 3.5 分面 

添加其他变量的一个方法是使用图形属性。另一个方法，尤其是对分类变量，把你的变量划分为不同的分面(facets)，每个分面显示一个数据集的子集。

为了根据一个单一的变量把图形划分为不同的分面，可以使用facet_wrap()。facet_wrap()的第一个参数是公式，你可以通过~ 变量名创建公式(这里的公式"formula"是R中的数据结构的名称，而非一个方程(equation))。facet_wrap()中变量必须是分类型变量。

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

为了根据两个变量的组合把图形划分为不同的分面，你需要使用facet_grid()。facet_grid()的第一个参数也是公式。此时的公式包含两个变量，这两个变量用 ~ 分隔。

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```

#### 3.5.1 练习

1. 如果你分面一个联系型变量，会发生什么呢？

2. 不使用facet_grid(drv ~ cyl)意味着什么？它们与图形有何关系？

   ```
   ggplot(data = mpg) + 
     geom_point(mapping = aes(x = drv, y = cyl))
   ```

3. 下面的代码会创建什么样的图形？. 是什么意思？

   ```
   ggplot(data = mpg) + 
     geom_point(mapping = aes(x = displ, y = hwy)) +
     facet_grid(drv ~ .)

   ggplot(data = mpg) + 
     geom_point(mapping = aes(x = displ, y = hwy)) +
     facet_grid(. ~ cyl)
   ```

4. 这一节的第一个面图

   ```
   ggplot(data = mpg) + 
     geom_point(mapping = aes(x = displ, y = hwy)) + 
     facet_wrap(~ class, nrow = 2)
   ```

   使用分位而不使用图形属性有哪些好处？那些坏处？如果你有个大的数据集，这个平衡可能会发生什么变化呢？

5. 阅读 ?facet_wrap()。nrow是什么意思？ncol是什么意思？其他何种参数控制着画图板的布置？为什么facet_grid()不需要nrow和ncol变量？

6. 当使用fracet_grid()，你通常应该使用分类变量值的列？为什么？

### 3.6 几何对象

这两幅图有多大的相似度？
这两个图有相同的x和y变量，描述的是相同的数据。但是这两个图却是不相同的。每个图像使用一个不同可视对象来展现数据。在ggplot中，我们说他们采用 了不同的几何图形。

几何图形是几何对象，图像用它来展现数据。人们使用不同的几何对象来展示图形。例如，条形图使用bar对象，线图形使用line几何对象，箱图使用boxplot对象等等。散点图会破坏趋势，他们使用的是点。如我们上面看到的，我们可以使用不同的几何对象来描述相同的数据。左边使用的是点图，右边使用的光滑几何图，一个光滑的线来模拟数据。

为了改变图形的几何对象，可以改变几何对象函数要添加ggplot()中。例如，创建上面的图形，你可以使用这段代码：

```
# left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

# right
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

在ggplot2中每个几何对象都一个映射(mapping)参数。无论如何，并不是每一个图形属性都对几何对象都能有效。你可以改变点的形状，你并不能改变线的形状。另一方面，你可以设置线的类型。geom_smooth()可以画一个不同的线，每个变量的值对应一种不同的线型。

```
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

这里geom_smooth()可以把汽车依据drv的值画出三种不同的类型。drv描述的是汽车的驱动系统。一种线描述的是所有值为4的点，一种线描述的是所有值为f的点，最后一种线描述的是所有值为r的点。这里，4代表是四轮驱动，f代表的前轮驱动，r代表的是后轮驱动。

如果这听起来很奇怪的，我们可以把线放到原始数据中，然后依据drv对所有对象着色，这可以它更加清晰。

注意到这幅图形中包含了两种几何对象。如果这使你感到兴奋，请记好安全带。在下一节中，我们将在同一幅图形中安放多个几何对象。

ggplot2提供了超过30种几何对象，同时扩展包提供了更多的几何对象。最好的方法是综合理解ggplot2备忘录。为了了解更多的关于每一个几何对象，使用帮助：?geom_smooth。

许多几何对象，如geom_smooth()，使用一个几何对象来显示不同列的数据。对于几何对象，你可以使用group图形属性设置一个分类变量来画多个图形对象。ggplot2把每一个分类对象的每一个值画出来。无论何时当你映射一个分类变量到图形属性上，ggplot2将自动划分数据到几何对象上。依据这个特性，group图形属性并不能添加图例到图形对象当中。

```
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
              
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
    
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, group = drv)
  )
```

为了能在同个图形中使用多个几何对象，可以向ggplot()中添加多个几何函数：

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

这里，无论如何，我们的代码有些重复。假设如果希望用cty来替换hwy作为y轴。你需要改变两个地方的变量，这其中你可能会忘记更改一个。你可以在ggplot()中设置一系列一系列映射避免重复。ggplot2 可以把映射设置为全局映射应用到图像的每个图层当中。换句话说，这些代码会创建先前代码同样的图像。

```
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

如果你把映射放在几何函数中，ggplot2将把它们作为图层的局域设置。为这幅图层，它将使用这些映射来替换全局设置。这将使不同的图层使用不同的图形属性成为可能。

```
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

你可以使用同样的方法为每个图层限定不同的数据。这里，我们光滑曲线仅显示了mpg的一部分数据集，超小型汽车(subcompact cars)。geom_smooth()将为图层使用局域数据设置来替换ggplot()中的全局数据设置。

```
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
```

#### 3.6.1 练习

1. 画线图的时候你会使用什么样的几何对象？箱线图？条形图？面积图？

2. 在你脑海里运行前面这个代码，预测会出现什么样的结果。那么，接着在R中运行这个代码，检测你的预测。

   ```
   library(ggplot2)
   ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
     geom_point() + 
     geom_smooth()
   ```

3. show.legend = FALSE是什么意思呢？如果移除它，会出现什么样的结果呢？你认为我为什么在这一章这么早点使用它呢？

4. geom_smooth函数中se参数有什么作用？

5. 这两张图形有什么不一样？为什么会出现这种状况？

   ```
   ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
     geom_point() + 
     geom_smooth()

   ggplot() + 
     geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
     geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
   ```

   ​


6. 重新编写R代码生成下面的图形。

### 3.7 统计转化

下面，我们看一下条形图。条形图似乎是简单的，但是它们是非常有趣的因为它们揭示了图形的一些微妙细节。对于一个基本的条形图，你可以使用geom_bar()创建。这一节接下来的部分将按diamonds数据集中的cut显示钻石的数量。diamonds数据集来自于ggplot2，包含着约5400钻石的信息，包括每颗钻石的价格(price)，克拉重量(carat)，颜色(color)，净度(clarity)，和切工(cut)。这幅图表明拥有高品质切割的黄金更受欢迎。

```
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

图中x轴显示的是diamond中的切工(cut)变量。y轴显示的钻石的数量(count)，count并不是diamonds数据集中的一个变量。count来自哪里呢？许多图形，如散点图，展示的是数据集中原始值。也有一些图形，如条形图，根据计算的新值来画图。

* 条形图，直方图，和频率多边形图划分数据并画出每个数据条的数量，即落在每个数据条的点的数量
* 光滑线会拟合你的数据，接着展示拟合模型中的预测结果
* 箱线图会对分布做一个简要的统计，接着展示一个特殊格式的箱线图。

图形计算新值算法被称为统计(stat)，它是统计变换的简称。下面这幅图展示geom_bar()的处理过程。

你可以通过查看stat的默认值来查看几何对象使用的默认统计。例如，?geom_bar 显示stat的值为count，这意味着geom_bar()使用stat_count()。stat_count()的说明文档和geom_bar()在同一页。如果你向下翻，你会发现计算变量(Computed variables)部分。这里指出它计算了两个新的变量：count和prop。

在使用的时候，你可以呼唤几何对象和统计变换。例如，你可以用stat_count代替上一幅图当中的geom_bar()：

```
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))
```

这两种方法之所以都能实现是因为每个几何对象都有一个默认的统计变换，每个统计变换都有一个默认的几何对象。这意味着你通常可以使用几何对象而不用担心内在的的统计变换。在下面三种情况下，你可能需要直接使用统计变换。

1. 你需要重新编写默认的统计变换。在下面的代码中，我把geom_bar()的统计变换从默认的count变成了identy(不对数据进行统计变换)。这意味着条的高度是y的原始值。不过，我们在谈论条形图的时候，我们通常是指每类条带的个数，而条带本身的高度常存在于数据当中。

2. 你需要重新编写映射。例如，你可能需要展示一个比例条形图，而非计数条形图。

   ```
   ggplot(data = diamonds) + 
     geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
   ```

3. 你可能更加关注统计变换。例如，你能需要使用stat_summary()，它会给出每个唯一的x对应的y值的情况。

   ```
   ggplot(data = diamonds) + 
     stat_summary(
       mapping = aes(x = cut, y = depth),
       fun.ymin = min,
       fun.ymax = max,
       fun.y = median
     )
   ```
#### 3.7.1 练习

1.    stat_summary对应的默认几何对象是什么？使用几何对象替换统计变换，你应该如何编写上面那幅图形的代码？

2.    geom_col()是什么意思？它和geom_bar()有什么不同？

### 3.8 位置调整

条形图相关的其它特点。你可以使用colour属性和更加有用的fill对条形图着色。

```
ggplot(data = diamonds) + 
geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
geom_bar(mapping = aes(x = cut, fill = cut))
```

### 4.工作流程：基础
你现在已经有了些运行R代码的经验。我并没有讲述很多的细节，但是显然你已经弄清楚基础的知识。或者你已经失望地把这本书扔了。在用R编程的时候沮丧失望是很自然的，因为它是对符号是如此苛刻，甚至一个放错位置的字符都会引起错误。但是当你沮丧失望时，一点要放轻松，那只是很常见和短暂的，克服它的唯一方法是持续地尝试。

在我们继续更深地学习之前，需要确保你已经有了很坚实的R编程基础，你已经知道了一些Rstudio常用属性。


### 7 探索性数据分析
#### 7.1 引言
这一章将讲述如何使用可视化和数据转化的方法系统地分析你的数据。这个过程在统计学上被称作探索性数据分析，简称EDA。它是一个迭代循环的过程。其中你需要：
1. 依据数据提出问题
2. 通过可视化，转化和模拟数据寻找答案
3. 通过你的了解重新定义你的问题或者提出新的问题。

EDA并不是一个有一系列严苛规则的过程。它更多的是一种思路。在EDA的初始阶段，你可以很自由的验证你的每一个想法。一些想法将会奏效，也有一些也会失败。当你继续分析的时候，你会锁定在一些特别具有生产力的领域，你甚至会写信和他人交流。

EDA是数据分析的一个重要部分，即使问题已经提交到你的手里，因为你常常需要检验数据的质量。数据清理只是EDA的一种实现方式。你需要确认你的数据是否满足你的要求。为了完成数据清理，你需要运用所有的EDA工具：可视化，数据转化和数据模拟。

##### 7.1.1 前提
在这一章我们将汇总你学到的所有关于dplyr和ggplot2的知识使用交换的方式针对数据提出问题，解决问题，接着提出新的问题。

```
library(tidyverse)
```


### 7.2 问题

EDA的目的是让你了解你的数据。了解你的数据的一个更加简单的方法是用问题来指导的你的分析。当你提出一个问题，这个问题会迫使你关注你数据集的特定部分，帮助你决定究竟使用图形、模型还是数据转化。

EDA是创意性过程的基础。如同大多数创意性过程，提出一个高质量的问题的关键是提出大量的小问题。在刚开始数据分析的时候很难提出深刻的问题，因为你不了解数据中包含的信息。另一方面，你每提出一个新问题都会让你从一个新的方面来理解这个数据，有机会有新的发现。如果你能跟进每一问题以及产生的新的问题，你会很快深入到数据当中最有趣的部分，并形成一系列发人深省的问题。

关于提出那些指导你研究的问题并没有统一的方法。无论如何，在探索数据时，两个问题的提出是非常有帮助的。这两个问题可以概括为：
1. 变量内部存在何种变异？
2. 变量间存在何种协变异？

这一章接下来的部分将讲述这两个问题。我将讲述什么是变异，协变异，同时用几种不同的方法回答每个问题。为了使讨论更加容易，我们需要定义一些术语：

* **变量**是你能够测量的数量，质量和性质。
* **值**是你所测量变量的描述。变量值在不同的测量中会发生变化。
* **观察**是在相同条件下的一系列测量(通常在一次观测中你能够同时对一个对象进行多个测量)。一个观察通常包含多个值，每个值对应不同的变量。有时，我也把观察称作数据点。
  **列表数据**是一系列值，每个值都与变量和观察相对应。如果每个值都放在它自己的单元格中，列表数据是非常整齐的，每一列对应一个变量，每一行组成一个记录。
  截至目前，你所遇到的所有数据都是整齐的。现实生活中，大多数数据往往并不是整齐的，因此在数据整理这一张我们将重新思考这些知识。

### 7.3 变异

变异是变量在多次测量中的值的趋势。现实生活中，你很容易的观察到变异。如果你两次测量任何一个连续型变量，你将会得到两个不同的值。即使你多次测量一个常量，如光速，这种情况仍然会出现。在每次测量当中都为会有少量的误差。如果你对不同的对象(例如，不同人眼睛的颜色)或者在不同的时间测量(电子在不同时刻的能量水平)，分类变量也会发生变化。每个变量都有它自己变异格局，能够反映非常有趣的信息。理解这种格局的最好方法是可视化变量值的分布。

#### 7.3.1 可视化分布

你如何可视化变量的分布依赖于变量是分类型变量和连续型变量。如果一个变量只能取一小组变量中的一个，那么这个变量是分类型变量。在R中，分类型变量通常被存储为因子型或者字符型变量。为了验证分类型变量的分布，使用条形图：

```
 ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut))
```

条的高度表示的是每个x值对应的观测的个数。你可以用dplyr::count()手动计算这些值的个数：

```
diamonds %>% count(cut)
```

如果一个变量可以取无穷有序值的任意一个，那么这个变量是连续型变量。数字和日期时间是两个连续型变量。为了验证连续型变量的分布，可以使用直方图：

```
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)
```

你可以使用dplyr::count()和ggplot2::cut_width()计算这个。

```
diamonds %>% 
  count(cut_width(carat, 0.5))
```

直方图可以把x轴划分为均匀的条带，使用条形图的高度展示落在每个条带的观测值的个数。在上面图的中，最高的条带表明克拉重量落在0.25到0.75的条带内的的钻石的个数为30000。

你可以使用binwidth参数设置条形图的间隔的宽度。当处理直方图时，你通常可以尝试一系列条带的宽度，因为不同的条带宽度能展现出不同的格局。例如，这里如果我们仅处理克拉重量小于3克拉并选择更小的宽度，上面的图会怎么样呢？

```
smaller <- diamonds %>% 
  filter(carat < 3)

ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.1)
```

如果你希望覆盖多个直方图在同一个画布上，我建议你使用geom_freqploy()替换geom_histogram()。geom_freqploy()可以完成geom_histogram()相同的计算，但是这里用线来代替条形图的个数。覆盖线型图比条形图更容易理解。

```
ggplot(data = smaller, mapping = aes(x = carat, colour = cut)) +
  geom_freqpoly(binwidth = 0.1)
```

这种类型的图中还存在着一系列的挑战，在可视化分类变量和连续型变量中，我们将重新考虑这个问题。

现在你能够可视化变异，在图形中你能够发现什么呢？你能够提出什么类型的后续问题呢？我已经列出了一系列你在图形中会发现的有用的信息，以及每类信息背后各种后续问题。提出好的后续问题的关键是依赖于你的好奇心和怀疑态度。

#### 7.3.2 典型值

在条形图和直方图中，高的条带图表示的是一个变量的常见值，而低的条带表示的不太常见的值。没有的条带的地方表明这些值不存在于数据当中。为了把这些信息转化有用的问题，查找那些没有预料到的事情。

* 那些值最常见？为什么？
* 那些值比较少？为什么？这与你的预期相符吗？
* 你能够看出那些不常见的格局？什么能够解释这种格局？

例如，下面这个直方图能够显示几个有趣问题：

* 为什么<...>
* 为什么在每个极值右侧的钻石略多于极值右侧钻石？
* 没什么没有钻石的克拉重大于3克拉？

```
ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.01)
```

相似值的聚类表明在你的数据中小的分组存在。为了能够了解小的分组，提出这些问题：

* 不同的聚类之间是否相似？
* 不同的聚类之间是否不同？
* 如何解释和描述这些聚类？
* 这些聚类为什么会存在误导？

下面的直方图表示的是黄石国家公园老实泉的272次喷发的时间长度。喷发时间可以划分为两类。一个是2分钟左右的短喷发和4到5分分钟的长喷发。

```
ggplot(data = faithful, mapping = aes(x = eruptions)) + 
  geom_histogram(binwidth = 0.25)
```

上面的许多问题促使你探索分析不同变量之间的关系，例如，查看一个变量的值能否解释另一个变量的变化。我们就很快理解这些。

#### 7.3.3 不常见值

异常值在观测当中不常见。异常值的数据点不能模拟格局。有时候异常值可能是数据录入错误；而有时候异常值可能表明了新的科学。当你拥有大量的数据的时候，异常值有时在直方图中很难发现。例如，钻石数据集中y变量。异常值的唯一证据是y轴上异常广泛的限制。

```
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)
```

在常见的条带中有如此多的常见值，以至于你几乎不能看到那些不常见的低矮的条带。为了能够更容易查看那些不常见的值，我们需要使用coor_cartesian()放大y轴小值。

```
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50))
```

当你要放大x轴，你可以在coord_cartesian()进行xlim设置。ggplot2中也有xlim()和ylim()函数，它们略有不同，能够抛出限制以外的数据。

这允许我们查看三个不常见的值：0，~30和~60。我们使用dplyr来找出它：

```
unusual <- diamonds %>% 
  filter(y < 3 | y > 20) %>% 
  arrange(y)
unusual
#> # A tibble: 9 × 10
#>   carat       cut color clarity depth table price     x     y     z
#>   <dbl>     <ord> <ord>   <ord> <dbl> <dbl> <int> <dbl> <dbl> <dbl>
#> 1  1.00 Very Good     H     VS2  63.3    53  5139  0.00   0.0  0.00
#> 2  1.14      Fair     G     VS1  57.5    67  6381  0.00   0.0  0.00
#> 3  1.56     Ideal     G     VS2  62.2    54 12800  0.00   0.0  0.00
#> 4  1.20   Premium     D    VVS1  62.1    59 15686  0.00   0.0  0.00
#> 5  2.25   Premium     H     SI2  62.8    59 18034  0.00   0.0  0.00
#> 6  0.71      Good     F     SI2  64.1    60  2130  0.00   0.0  0.00
#> 7  0.71      Good     F     SI2  64.1    60  2130  0.00   0.0  0.00
#> 8  0.51     Ideal     E     VS1  61.8    55  2075  5.15  31.8  5.12
#> 9  2.00   Premium     H     SI2  58.9    57 12210  8.09  58.9  8.06
```

y变量是钻石三维的一个，单位是mm。我们知道钻石没有0mm的宽度，因此这些值是不正确的。我们也怀疑32mm和59mm的测量时不可靠。这些钻石超过1英尺的长度，却不没有成千上万的价值。

用是否包含异常值的数据重复你的分析非常好的办法。如果它们对结果影响微乎其微，你不知道它们为什么存在，利用没有缺失值的数据替换它们，进一步分析是非常合理的。无论如何，如果它们对数据产生很大的影响，你不应该在判断之前抛弃它们。你需要明白什么造成了这种现象(例如，数据输入错误)，也表明你需要在文章中删除它们。

#### 7.3.4 练习

1. 探索分析钻石的x，y和z的分布。你能获得怎样的信息？思考钻石，究竟长、宽和深度究竟哪个维度决定觉得这一个钻石？
2. 探索分析钻石价格的分布。你会发现那些不寻常或者奇怪的事情？(提示：仔细考虑条带的宽度，确信你尝试了一系列的值)
3. 0.99克拉重的钻石又多少个？1克拉重的钻石有多少个？你认为什么原因造成了这种差异？
4. 当你放大条形图的时候，比较和对比coor_cartesian()和xlim()或者ylim()。如果你不设置条带宽度会发生什么状况？如果你试图放大一半的条带会发生什么状况？

### 7.4 缺失值

如果在你的数据集中碰到了一些不常见值，为了能够接着分析，你会有两个想法。

1. 删除包含异常值的数据行

```
diamonds2 <- diamonds %>% 
  filter(between(y, 3, 20))
```

我并不推荐使用这种方法，因为只是其中的一个测量值是无效的，并不意味着所有的测量值都无效。此外，如果你有很少的数据，你对每个变量都使用相同的方法，你可能发现最终你的数据所剩无几。

2. 相反，我建议使用缺失值替换那些不常见的值。最简单的方法是使用mutate()函数对变量进行修改。你可以使用ifelse()函数用NA替换那些不常见的值。

```
diamonds2 <- diamonds %>% 
  mutate(y = ifelse(y < 3 | y > 20, NA, y))
```

ifelse()有三个参数。第一个参数test是一个逻辑型向量。如果test是TRUE，这个结果是第二个参数的值，反之，如果test是FALSE，结果是第三个参数的值。

ggplot2与R遵守相同的原则，缺失值并不会默认消失。当使用ggplot2对包含缺失值的数据画图的时候，缺失值并不明，。但是它会提醒缺失值被删除了。

```
ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + 
  geom_point()
#> Warning: Removed 9 rows containing missing values (geom_point).
```

为了避免这一警告，你可以设置 na.rm = TRUE:

```
ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + 
  geom_point(na.rm = TRUE)
```

有时候你希望明白是否包含缺失数据的数据间的差异。例如， 在nycflights13::flights数据中，变量dep_time的缺失值表示的是取消的航班。因此你可以比较取消航班和非取消航班次数间的差异。你可以使用is.na()创建一个新的变量。

```
nycflights13::flights %>% 
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + sched_min / 60
  ) %>% 
  ggplot(mapping = aes(sched_dep_time)) + 
    geom_freqpoly(mapping = aes(colour = cancelled), binwidth = 1/4)
```

无论如何这个图的效果并不理想，因为相比取消的航班，有如此多的航班并没有取消。在下面一节，我们将使用一些方法改进这个比较。

#### 7.4.1 练习

1. 如果直方图中存在缺失值，会发生什么情况？条形图中存在缺失值，又会发生什么情况？两者有何差异？
2. na.ram在mean()和sum()函数中有什么作用？

### 7.5 协变异

如果说变异描述的变量内部的变化，协变量描述的变量之间的变化。协变异描述的是两个或多个变量之间的变化趋势。描述协变量的最好方法是可视化两个或多个变量之间的关系找出协变异。同样，如何画图也取决于变量的类型。

#### 7.5.1 连续型变量和连续型变量

探究连续型变量依据一个分类型变量的分布是比较常见的，如前面的频率多边形。geom_freqpoly()默认的设置对于这类比较并不是非常有用的，因为高度是个数。那意味着如果一个分组比其他的分组低，那是很难看出形状上的差异的。例如，我们可以分析一下钻石的价格随着其切工的变化。

```
ggplot(data = diamonds, mapping = aes(x = price)) + 
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)
```

